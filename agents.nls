buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  bus_route       ; fixed route of the agent (bus)
  temp_route      ; Temporary route until it reaches the target bus-stop
  send_route      ; used by bus 24 to store routes and other to store recieved routes ID
  vote            ; used by bus 24
  all_bus_capacity; used by bus 24
  route_flag      ; used by bus 24 to send update request and others to update
  route_list      ; list of available routes
  waiting_p_count ; count of passenger left behind
  nomad           ; Bus out of fixed route
  mean_capacity   ; Bus mean capacity percent
  empty_bus       ; Used by bus 24
]
 
extensions [nw]

globals [graph]

to init-buses
  ; Initialize your agents here.
  ; Default route
  let route1 [4 5 16 11 17 7 1 19 23 14 0 15 18 15 12 22 13 10 21 20 9 8 2 8 6 8 9 3] ; starts at 3
  ; Shorter routes
  let orange_route [9 20 12 15 18 15 12 20 9 3]
  let brown_route [9 8 6 8 2 8 9 3]
  let green_route [4 10 13 23 19 1 19 23 13 10 4 3]
  let blue_route [20 21 22 0 14 0 22 21 20 3]
  let red_route [4 5 10 7 17 11 16 11 17 7 10 5 4 3]
  let flip_num random 7
  
  let temp_route_list (list (list 0 route1) (list 1 orange_route) (list 2 brown_route) (list 3 green_route) (list 4 blue_route) (list 5 red_route))
  
  set temp_route []
  let total_buses count buses
  
  ask buses [
    ; if route list containing all routes information is not initialized, initial it here
    if not is-list? route_list[
      set route_list temp_route_list
    ]
    ; if bus's fixed route is not initialized, initialize it here
    if not is-list? bus_route [
      set count_bus (count_bus + 1)
      set send_route []
	  
	  ; setting the default route
      set bus_route route1
      set nomad false
      
	  ; updating the default route of all the new buses except bus 24 based on the probability
      if count_bus > 2 [ 
         ifelse flip_num = 0[
           set send_route (list 1)
           set-bus-route 
           ;set bus_route orange_route
         ][
           ifelse flip_num = 1[
             set send_route (list 2)
             set-bus-route 
             ;set bus_route brown_route
           ][
             ifelse flip_num = 2[
               set send_route (list 3)
               set-bus-route 
               ;set bus_route green_route
             ][
               ifelse flip_num = 3[
                 set send_route (list 4)
                 set-bus-route 
                 ;set bus_route blue_route
               ][
                 if flip_num = 4[
                   set send_route (list 5)
                   set-bus-route 
                   ;set bus_route red_route
                 ]
               ]
             ]
           ]
         ]
      ]
      
      ; initialize other variables to default values
      set route_flag false
      set vote []
      update-vote bus_id 0 0 0 0
      set all_bus_capacity 0
      set mean_capacity 100
      set empty_bus []  
      
      ; delete
      ifelse bus_type = 1[
        set count_green (count_green + 1)
      ][
        ifelse bus_type = 2[
          set count_yellow (count_yellow + 1)
        ][
          if bus_type = 3[
            set count_red (count_red + 1)
          ]
        ]
      ]
    ]
  ]
    
  nw:set-context bus_stops routes
  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
end

to execute-actions
  ; Add decision making strategies for your agents here.
  ; You are allowed to use the global variable 'ticks'.
  
  ; take action for passenger
  process-passenger 
  
  ; process incoming message
  process-message
  
  ; move the bus
  run-bus 
  
  ; add new buses
  if bus_id = 24[
    add-bus-type 
  ]
  
  ; Send message
  communicate

end

; This method will process the passenger pickup and drop request only in a bus-stop. It folows three types of behavior depending on the 
; its current bus-stop and whether passenger destination addressing or not
to process-passenger
  if current_stop != -1 [
    
    foreach bus_passengers [
      ; Drop only those passengers whose destination is current bus-stop or if it is the central station/hub
      if item 1 ? = current_stop or current_stop = 3[
        drop-off-passenger item 0 ?
      ]
    ]
    
    foreach get-passengers-at-stop current_stop [
	; Pickup only those passengers at the central station whose destination belongs to current buses route
      if current_stop = 3 and member? item 1 ? bus_route [
        pick-up-passenger item 0 ?
      ]
	  ; Pickup all the passengers if bus is traveling in its fixed route and not passenger addressing
      if current_stop != 3 and not nomad[
        pick-up-passenger item 0 ?
      ]
      ; Pickup only those passengers who belong to its temporary or permanent route when passenger addressing
      if current_stop != 3 and nomad and (member? item 1 ? temp_route or member? item 1 ? bus_route)[
        pick-up-passenger item 0 ?
      ]
    ]
    
    let capacity_percent item 1 get-bus-capacity
    ; if empty seats is less than 10% start addressing the passengers
    if capacity_percent < 10 and bus_id != 24[
      set-passenger-route
      set nomad true
    ]
  ]
  
end

; This method will move the bus by one tile towards the target bus-stop
to run-bus
  ; if temporary route is not set, follow fixed route
  ifelse empty? temp_route [

    let target_id item 0 bus_route
 
    ; if the current bus-stop and next destination are adjacent move towards the target otherwise generate a 
    ; temporary shortest route to that target bus-stop route
    ifelse is-link? route bus_id target_id [    
      travel-to target_id
      if current_stop = target_id [
        set bus_route but-first bus_route
        set bus_route lput target_id bus_route
      ]
    ][
      ; generate the temporary shortest route to next target in the fixed route
      set-temp-route target_id
    ]
    ; reset the passenger addressing flag after returning to fixed route
    set nomad false
  ][
    ; if temporary route is set implies either it is passenger addressing or it is travelling to next target 
    ; which is not adjacent
    let target_id item 0 temp_route
    
    ; update the original route if next temporary route bus-stop is same as next original route bus-stop 
    if target_id = first bus_route [
      let target_bs item 0 bus_route
	  ; update fixed route (circular array)
      set bus_route but-first bus_route
      set bus_route lput target_bs bus_route
    ]
    ; move one tile
    travel-to target_id
	; update temporary route
    if current_stop = target_id [
      set temp_route but-first temp_route
    ]
  ]
  
  ; reset mean capacity percentage once bus travels out of central station
  if previous_stop = 3[
;    print (word " MEAN " mean_capacity " Bus" bus_id)
    set mean_capacity 100
  ]
  
end

; The method process the received messages in the inbox
to process-message
; if inbox is not empty
if length inbox > 0 [
  ; unpack the message
  let read_msg item 0 inbox
  let recieved_msg item 2 read_msg
  
  let temp_command 0
  let bus_number 0
  let update_empty_bus false
  
  ; loop untill the whole message is read
  while [ not empty? recieved_msg]
  [
    let temp_command_value 0
    
	; separate the keyword and values
    ifelse is-string? first recieved_msg [
      set temp_command item 0 recieved_msg
    ][
      set temp_command_value item 0 recieved_msg
    ]
	; update the message
    set recieved_msg but-first recieved_msg
    
      ifelse temp_command = "GEN" [
        ; execute general method
        ; if the sender bus is running set empty flag for updating the information
        if temp_command_value = 2[
          set update_empty_bus true
        ]
      ][
        ifelse temp_command = "BUS" [
          ; execute Bus specific command
          set bus_number temp_command_value
          
		  ; if agent is bus 24 and update empty flag is set for the sender, update bus 24 internal list to store this information
          if bus_id = 24 and update_empty_bus[
;           ; update bus number of sender only if it is not present
            if not member? bus_number empty_bus[
              set empty_bus lput bus_number empty_bus
            ]
          ]
        ][
          ifelse temp_command = "CAPACITY" [
		    ; execute capacity spcific information
          
            ; if agent is bus 24 then add sender empty seat information to the total number of empty seat
            if bus_id = 24 and temp_command_value > 0[
              set all_bus_capacity (all_bus_capacity + temp_command_value)
            ]
          ][
            ifelse temp_command = "BUS_S" [
              ; execute Bus-stop specific command
              ; if sender is calling for assistance, generate a temporary route to that target bus-stop
              if bus_id != 24 and temp_command_value > 0[
                set-temp-route temp_command_value
              ]
            ][
              ifelse temp_command = "PASS" [
                ; execute Passenger specific command
              ][
                ifelse temp_command = "ROUTE" [
                    ; execute route specific command

                    ; if the sender is bus 24 then treat the message specially
                    if is-list? temp_command_value and not empty? temp_command_value[
                      ; sender is bus 24 and current agent id is not 24
                      ifelse bus_number = 24 and bus_id != 24[
;                        ; process the new route request from sender
                        let new_route first temp_command_value
						; if the new route request if different from already pursuing route, update
                        if not empty? send_route and new_route != item 0 send_route[
                          print (word send_route " " new_route " " bus_id)
                          if not empty? send_route[
                            set send_route but-first send_route
                          ]
                          
                          set send_route lput new_route send_route
                          set-bus-route
                        ]
                      ][
                        if bus_id = 24[
                          ; update the senders route into the list
                          if not member? temp_command_value send_route[
                            set send_route fput temp_command_value send_route
                          ]
                        ]
                      ]
                    ]              
                ][
                  if temp_command = "VOTE" [
                    ; process vote received by bus 24 for voting
                    if bus_id = 24 and is-list? temp_command_value and not empty? temp_command_value and item 0 temp_command_value != 0[
                      update-vote bus_number item 0 temp_command_value item 1 temp_command_value item 2 temp_command_value item 3 temp_command_value
                    ]
                  ]
                ]
              ]
            ]
          ]
        ]
      ]
    ]
    set inbox remove read_msg inbox
  ]
  

end

; This method updates the votes of agents in bus 24 storage
to update-vote[bus_number choice1 choice2 choice3 bus_count]
  ask bus 24[
    ; update the vote
    if not empty? vote[
      foreach vote[
        if item 0 ? = bus_number[
          set vote remove ? vote
        ]
      ]
    ]
    set vote lput (list bus_number choice1 choice2 choice3 bus_count) vote
  ]
end

; This method is used to construct a message structure with the related information
to-report construct-message
  let message []
  let bus_capacity item 0 get-bus-capacity
  let send_capacity_flag false
  let send_vote_flag false

  ; general messages
  set message lput "GEN" message
  ; if bus is full the set it to 1
  if bus_capacity < 1[
    ; set general message bus is full
    set message lput 1 message
  ]
  
  ; if buses average empty seat percentage is more than 90 in a complete round trip then set value 2 
  ; to indicate re-routing required for this bus 
  if current_stop = 3 and mean_capacity > 90 and bus_id != 24[
    set message lput 2 message
    set send_capacity_flag true
  ]
     
    
  ; Bus specific message, Bus ID
  set message lput "BUS" message
  set message lput bus_id message
  
  ; Number of empty seats
  set message lput "CAPACITY" message
  set message lput item 0 get-bus-capacity message
  
  ; Bus-stop specific message, Bus-stop ID
  set message lput "BUS_S" message
  set message lput current_stop message
  
  ; Passenger specific message
  set message lput "PASS" message
  
  ; Route specific message
  set message lput "ROUTE" message
  ; if agent is bus 24 then send the new route information to the receiver 
  ifelse bus_id = 24 and route_flag and not empty? send_route[
    ;print (word "send_route before for bus" bus_id " " send_route)
    set message lput item 0 send_route message
    set send_route but-first send_route
  ][
    set message lput send_route message
  ]
  
  ; Vote of individual bus
  set message lput "VOTE" message
  let vote_recieved take-vote
  if item 0 vote_recieved != 0[
    set send_vote_flag true
  ]
  set message lput vote_recieved message
  
  report (list send_capacity_flag send_vote_flag message)
end

; this method is used to communicate between agents by building a message packet and sending it to correct addressee
to communicate
  let message []
  let addressee 0
  let send_capacity_flag false
  let send_vote_flag false

  ; If bus is at a bus-stop,
  if current_stop != -1 [

    ; construct message with additional information
    set message construct-message
    ; unpack message
    set send_capacity_flag item 0 message
    set send_vote_flag item 1 message
    ; extract the original packet to be sent 
    set message item 2 message

    ; send vote and/or capacity information to bus 24
    if (bus_id != 24) and (send_vote_flag or send_capacity_flag)[
      send-message 24 message
    ]
  ]
  
  ; if agent is bus 24 and there is empty bus request in a route then send the route information to an empty bus
  if bus_id = 24 and length send_route > 0[

    set route_flag true
    
    ; construct message
    set message construct-message
    set send_vote_flag item 1 message
    set message item 2 message
    
    ; send message to new bus
    set addressee get-addressee bus_id 
    
	; if addressee bus exist
    if count buses with [bus_id = addressee] > 0 [
      send-message addressee message
    ]
  ]
end


; return the number of empty seats, empty seat percent
to-report get-bus-capacity
  let empty_seats 0
  let passenger_at_stop 0
  let capacity_percent 0
  let alpha 0.1
  
  ; get the number of passenger waiting at the bus-stop
  if current_stop != -1 [
    set passenger_at_stop length get-passengers-at-stop current_stop
  ]
  
  ; calculate empty seats and percentage based on the type of bus
  ifelse bus_type = 1 [
    set empty_seats bus_type1_capacity - (length bus_passengers + passenger_at_stop)
    ; if empty seats is negative, i.e. more passengers are waiting than the bus capacity 
    ; then set empty seat to zero
    if empty_seats < 0[
       set empty_seats 0
    ]
    
	; calculate the empty seat percentage
    set capacity_percent (empty_seats / bus_type1_capacity) * 100  
  ][ 
    ; process for bus type 2
    ifelse bus_type = 2 [
      set empty_seats bus_type2_capacity - (length bus_passengers + passenger_at_stop)
      if empty_seats < 0[
        set empty_seats 0
      ]
      
	  ; calculate the empty seat percentage
      set capacity_percent (empty_seats / bus_type2_capacity) * 100
    ][ 
	   ; process for bus type 3
	   if bus_type = 3 [
        set empty_seats bus_type3_capacity - (length bus_passengers  + passenger_at_stop)
        
        if empty_seats < 0[
          set empty_seats 0
        ]
        
		; calculate the empty seat percentage
        set capacity_percent (empty_seats / bus_type3_capacity) * 100
      ]
    ]
  ]
  
  ; update the mean empty bus capacity percentage
  set mean_capacity (mean_capacity + (capacity_percent - mean_capacity) * alpha )
    
  report (list empty_seats capacity_percent)
end

; This method takes the preference of all three types of bus of an agent
to-report take-vote
  let report_vote [0 0 0 0]
  let capacity item 0 get-bus-capacity
  let vote_count 0
  
  let passengers_left 0
  
  ; number of passenger left after pickup
  if current_stop != -1[
    set passengers_left (length get-passengers-at-stop current_stop) - capacity
  ]
  
  ; increment the total number of passenger couldn't be picked up by agent
  if passengers_left > 0[
    set waiting_p_count (waiting_p_count + passengers_left)
  ]

  ; If number of waiting passengers left behind are more than bus type 1 capacity, send voting preference
  if waiting_p_count > bus_type1_capacity[
    let var_1 waiting_p_count / bus_type1_capacity
    let var_2 waiting_p_count / bus_type2_capacity
    let var_3 waiting_p_count / bus_type3_capacity
    
    ; total passengers waiting can fill var_x% seats of bus type x then bus type x should be 1st preference followed by decreasing order of bus capacity(default preference would be 1,2,3)
    ifelse (var_3 > 0.65)[
      set vote_count ceiling var_3
      
      ; setting vote preference to green bus, yellow bus, red bus
      set report_vote (list 3 2 1 vote_count)
      
      set waiting_p_count (waiting_p_count - (vote_count * bus_type3_capacity))
    ][
      ifelse (var_3 < 0.65 and var_2 > 0.5)[
        set vote_count ceiling var_2
        
        ; setting vote preference to yellow bus, green bus, red bus
        set report_vote (list 2 1 3 vote_count)
        
        set waiting_p_count (waiting_p_count - (vote_count * bus_type2_capacity))
      ][
        if var_1 > 1.3 [
          set vote_count ceiling var_1
          
          ; setting vote preference to green bus, yellow bus, red bus
          set report_vote (list 1 2 3 vote_count)
        
          set waiting_p_count (waiting_p_count - (vote_count * bus_type1_capacity))
        ]
      ]
    ]
  ]
  
  ; update the vote of bus 24 directly
  if bus_id = 24[
    update-vote 24 item 0 report_vote item 1 report_vote item 2 report_vote item 3 report_vote
  ]

  report report_vote
end

; This method is used to evaluate the borda voting scheme after every 3rd tick and add bus accordingly 
to add-bus-type 
  if remainder ticks 3 = 0[
  let green_vote 0
  let yellow_vote 0
  let red_vote 0
  let green_vote_count 0
  let yellow_vote_count 0
  let red_vote_count 0
  
  let winner 0
  let winner_count 0
  let winner_buses_total_capacity 0
  let winner_requested_bus 0
  
  let total_passenger_waiting 0

  let my_vote []
  ; update all bus capacity with bus 24 information as well
  set all_bus_capacity (all_bus_capacity + item 0 get-bus-capacity)
  
  ; take bus 24 vote
  if current_stop != -1[
    set my_vote take-vote
  ]
  
  ; evaluate the borga voting scheme for all the vote received
  foreach vote[
    ; using weighted borda from the first preference to take account of cost of bus, travel cost and seat capacity 
    ; of different type of bus. This weighing scheme ensures larger buses are added than small bus.
    ifelse item 1 ? = 1[
      set green_vote (green_vote + 3)
      set green_vote_count (green_vote_count + item 4 ?)
    ][
        ifelse item 1 ? = 2[
          set yellow_vote (yellow_vote + 4)
          set yellow_vote_count (yellow_vote_count + item 4 ?)
      ][
          if item 1 ? = 3[
            set red_vote (red_vote + 5)
            set red_vote_count (red_vote_count + item 4 ?)
        ]
      ]
    ]
    
	; second preference vote are given equal weights of 2
    ifelse item 2 ? = 1[
      set green_vote (green_vote + 2)
    ][
        ifelse item 2 ? = 2[
          set yellow_vote (yellow_vote + 2)
      ][
          if item 2 ? = 3[
            set red_vote (red_vote + 4)
        ]
      ]
    ]
    
    ifelse item 3 ? = 1[
      set green_vote (green_vote + 1)
    ][
        ifelse item 3 ? = 2[
          set yellow_vote (yellow_vote + 1)
      ][
          if item 3 ? = 3[
            set red_vote (red_vote + 2)
        ]
      ]
    ]
        
    ; reset the vote
    update-vote item 0 ? 0 0 0 0
    
  ]
  
  ; evaluating the winner and breaking tie by selecing the bus with more seats
  ifelse (red_vote > 0 ) and (red_vote >= green_vote) and (red_vote >= yellow_vote)[
    set winner 3
    set winner_count red_vote
	
	; evaluate the approximate number of bus required of winning type
    set winner_buses_total_capacity (red_vote_count * bus_type3_capacity)
	; multiplied by 3 to compensate for Borda weights
    set winner_requested_bus (red_vote_count * 3) / red_vote
    
  ][
    ifelse (yellow_vote > 0 ) and (yellow_vote >= green_vote) and (yellow_vote > red_vote)[
      set winner 2
      set winner_count yellow_vote
	  
	  ; evaluate the approximate number of bus required of winning type
      set winner_buses_total_capacity (yellow_vote_count * bus_type2_capacity)
	  ; multiplied by 3 to compensate for Borda weights
      set winner_requested_bus (yellow_vote_count * 3) / yellow_vote
    ][
      if (green_vote > 0 ) and (green_vote > yellow_vote) and (green_vote > red_vote)[
         set winner 1
         set winner_count green_vote
		 
		 ; evaluate the approximate number of bus required of winning type
         set winner_buses_total_capacity (green_vote_count * bus_type1_capacity)
		 ; multiplied by 3 to compensate for Borda weights
         set winner_requested_bus (green_vote_count * 3) / green_vote
      
      ]
    ]
  ]
  
  ; get total waiting passengers at all the bus-stop. This information is made available at any bus-stop
  ask bus_stops [
    set total_passenger_waiting (total_passenger_waiting + length passengers_waiting)
  ]
  
  ; Add buses only if the number of empty seats will decrease over the period of time
  if winner != 0 and  all_bus_capacity > ((all_bus_capacity + winner_buses_total_capacity) - total_passenger_waiting)[
    ; rather than always adding new bus, re-allocate the old buses and add only the needed only
	while [(winner_requested_bus - length empty_bus) > 0][
    add-bus winner
    set winner_requested_bus winner_requested_bus - 1
    ]
  ]
  ; reset all bus capacity to zero
  set all_bus_capacity 0
]
  
  

end


; helper method to get bus id of the addressee
; b_id: bus Id
; flag_new: If true report new bus id else report nearest bus id
; reports back bus-id of newest/nearest bus 
to-report get-addressee [b_id]
  let report_id 0
  
  ; if bus waiting for re-routing than report that bus id otherwise report newly added bus id
  ifelse not empty? empty_bus[
    ; empty bus id
    set report_id item 0 empty_bus
    print (word "RE-routing " item 0 empty_bus)
    set empty_bus but-first empty_bus
  ][
    let current_b_id count buses
    let new_b_id current_b_id + 23
    set report_id new_b_id
    print (word "Alloting new bus" report_id)
  ]
  
  report report_id
end



; Helper method to set up temporary route to target bus-stop for bus_id
to set-temp-route [target]
  let dummy_route []
  let path_list []
  let temp_stop current_stop
  let temp_var1 bus_stop current_stop
  let temp_var2 -1
  
  ; current stop could be -1 if the gent is traveling in between stop
  if current_stop = -1 [
    set temp_stop next_stop 
    set temp_var1 temp_stop
  ]
  
  ask bus_stop temp_stop [
    ; Construct the turtle path, putting the current bus_stop on the front:
    set path_list fput self nw:path-to bus_stop target
  ]
  set dummy_route lput bus_stop current_stop dummy_route
  
  
  ; remove the bus_stop information
  set path_list but-first path_list
  
  while [ not empty? path_list] [
    let path_item first path_list
    ask path_item [
      ;print (word "1. end1 " end1 " end2 " end2 " dummy route " dummy_route)

     ifelse end1 = temp_var1 [
       if member? temp_var1 dummy_route [
         set dummy_route remove temp_var1 dummy_route
       ]
       set dummy_route lput temp_var1 dummy_route
       set temp_var2 end2
       set dummy_route lput temp_var2 dummy_route
       ;print (word "2. end1 " end1 " end2 " end2 " dummy route " dummy_route)
     ][ 
         ifelse end2 = temp_var1 [
         if member? temp_var1 dummy_route [
           set dummy_route remove temp_var1 dummy_route
         ]
         set dummy_route lput temp_var1 dummy_route
         set temp_var2 end1
         set dummy_route lput temp_var2 dummy_route
         ;print (word "3. end1 " end1 " end2 " end2 " dummy route " dummy_route)
       ][
         set temp_var1 end1
         set dummy_route lput temp_var1 dummy_route
         set temp_var2 end2
         set dummy_route lput temp_var2 dummy_route
         ;print (word "4. end1 " end1 " end2 " end2 " dummy route " dummy_route)
       ]
     ]
     

    ]
      set path_list but-first path_list
    ]
  
  ; forming a circular route to return to original point of deviation
  set dummy_route remove-duplicates dummy_route
  let dummy_route_reverse reverse dummy_route
  foreach dummy_route [ set dummy_route_reverse lput ? dummy_route_reverse ]
  
  set dummy_route but-first dummy_route
  
  let temp_route_id 0
  foreach dummy_route[
    
    ask ? [set temp_route_id who]
    
    set temp_route lput temp_route_id temp_route
  ]
end

; helper method to evalute passenger addressing temporary route in increasing order of distance to destination
to set-passenger-route
  let temp_bus_route []

  let passenger_destination []
  let distance_passenger []
  
  
  foreach bus_passengers[
    let destination_distance 0
    set passenger_destination lput item 1 ? passenger_destination
    set destination_distance get-shortest-distance item 1 ? current_stop
    set distance_passenger lput (list destination_distance item 1 ?) distance_passenger
  ]
  
  if length distance_passenger > 1[
    set distance_passenger sort-by [first ?1 < first ?2] distance_passenger
  ]
  
  let old_bus_route temp_route
  
  ; put the new route in the front of current temporary route
  foreach distance_passenger[
    set old_bus_route lput item 1 ? old_bus_route
  ]
  
  ; update temporary route
  if not empty? temp_bus_route[
    set temp_route old_bus_route
  ]
  
end

; helper method to get shortest distance between two bus-stop irrespective of they are not adjacent or not
to-report get-shortest-distance [bs_1 bs_2]
  let shortest_distance 0
  let shortest_path []
  
  ; if bus-stops are adjacent
  ifelse is-link? route bs_1 bs_2 [
    set shortest_distance get-distance bs_1 bs_2
  ][
      ; find the shortest path between the non adjacent bus-stops
      ask bus_stop bs_1 [
      ; Construct the turtle path, putting the current bus_stop on the front:
      set shortest_path fput self nw:path-to bus_stop bs_2
    ]
      
    set shortest_path but-first shortest_path
    let temp bs_1
    
	; evaluate distance of the shortest path
    while [ not empty? shortest_path] [
      let path_item first shortest_path
      ask path_item [
        
        let end_1 0
        let end_2 0
        
        ask end1[
          set end_1 who
        ]
        
        ask end2[
          set end_2 who
        ]
        
        ifelse end_1 = temp[
          set shortest_distance (shortest_distance + get-distance temp end_2)
          set temp end_2
        ][
          set shortest_distance (shortest_distance + get-distance temp end_1)
          set temp end_1        
        ]
      ]
      
      set shortest_path but-first shortest_path
    ]
  ]
  report shortest_distance

end

; helper method to set fixed bus route
to set-bus-route
  if not empty? send_route[
    foreach route_list[
      if item 0 send_route = item 0 ?[
        set bus_route item 1 ? 
      ]
    ]
  ]
end