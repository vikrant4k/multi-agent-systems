buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  bus_route       ; fixed route of the agent (bus)
  temp_route      ; Temporary route until it reaches the target bus-stop
  send_route      ; used by bus 24 to store routes and other to store recieved routes ID
  vote            ; used by bus 24
  all_bus_capacity; used by bus 24
  route_flag      ; used by bus 24 to send update request and others to update
  route_list      ; list of available routes
  waiting_p_count ; count of passenger left behind
  nomad           ; Bus without fixed route
]
 
extensions [nw]

globals [graph]

to init-buses
  ; Initialize your agents here.
  let route1 [4 5 16 11 17 7 1 19 23 14 0 15 18 15 12 22 13 10 21 20 9 8 2 8 6 8 9 3] ; starts at 3
  let orange_route [9 20 12 15 18 3]
  let brown_route [9 8 6 8 2 3]
  let green_route [4 10 13 23 19 1 3]
  let blue_route [20 21 22 0 14 3]
  let red_route [4 5 10 7 17 11 16 3]
  let flip_num random 7
  
  let temp_route_list (list (list 0 route1) (list 1 orange_route) (list 2 brown_route) (list 3 green_route) (list 4 blue_route) (list 5 red_route))
  
  set temp_route []
  let total_buses count buses
  
  ask buses [
    
    if not is-list? route_list[
      set route_list temp_route_list
    ]
    
    if not is-list? bus_route [
      set count_bus (count_bus + 1)
      set send_route []
      set bus_route route1
      set nomad false
      
      if count_bus > 2 [
        ifelse flip_num = 5[
          set nomad true 
        ][  
          ifelse flip_num = 0[
            set send_route (list 1)
            set-bus-route 
            ;set bus_route orange_route
          ][
            ifelse flip_num = 1[
              set send_route (list 2)
              set-bus-route 
              ;set bus_route brown_route
            ][
              ifelse flip_num = 2[
                set send_route (list 3)
                set-bus-route 
                ;set bus_route green_route
              ][
                ifelse flip_num = 3[
                  set send_route (list 4)
                  set-bus-route 
                  ;set bus_route blue_route
                ][
                  if flip_num = 4[
                    set send_route (list 5)
                    set-bus-route 
                    ;set bus_route red_route
                  ]
                ]
              ]
            ]
          ]
        ]
      ]
      
      
      set route_flag false
      set vote []
      update-vote bus_id 0 0
      
      
      ; delete
      ifelse bus_type = 1[
        set count_green (count_green + 1)
      ][
        ifelse bus_type = 2[
          set count_yellow (count_yellow + 1)
        ][
          if bus_type = 3[
            set count_red (count_red + 1)
          ]
        ]
      ]
    ]
  ]
    
  nw:set-context bus_stops routes
  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
end

to execute-actions
  ; Add decision making strategies for your agents here.
  ; You are allowed to use the global variable 'ticks'.
  
  ; take action for passenger
  process-passenger 
  
  ; process incoming message
  process-message
  
  ; Updating temporary short path based on incoming message
  ; set-temp-route bus_id target + 1
  run-bus 
  
  ; add new buses
  if bus_id = 24[
    add-bus-type 
  ]
  
  ;; Send message
  communicate

end

to process-passenger
  if current_stop != -1 [
    ;print (word " " current_stop)
    foreach bus_passengers [
      ;print (word " " ? " what " )
      if item 1 ? = current_stop or current_stop = 3[
        drop-off-passenger item 0 ?
      ]
    ]
    ;print (word "B_stop " current_stop " " get-passengers-at-stop current_stop ) 
    foreach get-passengers-at-stop current_stop [
      if current_stop = 3 and member? item 1 ? bus_route [
        pick-up-passenger item 0 ?
      ]
      if current_stop != 3 [
        pick-up-passenger item 0 ?
      ]
    ]
    
    if nomad [
      set-passenger-route
    ]
  ]
  
end

to run-bus
  ;print (word " Bus " bus_id bus_route)
  ;print (word " Bus " bus_id temp_route)

  ifelse empty? temp_route [
    ;Target updation of fixed route, Temporary code
    let target_id item 0 bus_route
    ;print (word " " bus_route " Target " target_id)
    
    ; find path back to original route
    ifelse is-link? route bus_id target_id [    
      travel-to target_id
      if current_stop = target_id [
        set bus_route but-first bus_route
        set bus_route lput target_id bus_route
      ]
    ][
      ;print "2. SET temp route"
      set-temp-route target_id
    ]
  ][
    ;print (word "Bus" bus_id "temp_route " temp_route)
    let target item 0 temp_route
    let target_id 0
    
    ask target [ set target_id who]
    
    ; update original route if it is same as temporary route
    if target_id = first bus_route [
      let target_bs item 0 bus_route
      set bus_route but-first bus_route
      set bus_route lput target_bs bus_route
    ]

    travel-to target_id
    if current_stop = target_id [
      set temp_route but-first temp_route
    ]
  ]
  
end

to process-message

; process recieved message, TODO:: delegate to funtion in later stage
if length inbox > 0 [
  let read_msg item 0 inbox
  let recieved_msg item 2 read_msg
  
  let temp_command 0
  let bus_number 0
  
  ;print(word "PROCESS message by BUS " bus_id " : " recieved_msg)
  
  while [ not empty? recieved_msg]
  [
    let temp_command_value 0
    
    ifelse is-string? first recieved_msg [
      set temp_command item 0 recieved_msg
    ]
    [
      set temp_command_value item 0 recieved_msg
    ]
    set recieved_msg but-first recieved_msg
    
      ifelse temp_command = "GEN" [
        ; execute general method
      ][
        ifelse temp_command = "BUS" [
          ; execute Bus specific command
          set bus_number temp_command_value
        ][
          ifelse temp_command = "CAPACITY" [
            if bus_id = 24 and temp_command_value > 0[
              set all_bus_capacity (all_bus_capacity + temp_command_value)
            ]
          ][
            ifelse temp_command = "BUS_S" [
              ; execute Bus-stop specific command
              ; update temporary route to sender's bus-stop
              ; USEGEN FLAG to avoid such specific check
              if bus_id != 24 and temp_command_value > 0[
                set-temp-route temp_command_value
              ]
            ][
              ifelse temp_command = "PASS" [
                ; execute Passenger specific command
              ][
                ifelse temp_command = "ROUTE" [
                    ; execute route specific command

                    ;print (word " BOOM " is-list? temp_command_value " 2nd " temp_command_value)
                    if is-list? temp_command_value and not empty? temp_command_value[
                      ;print " BAAM "
                      ifelse bus_number = 24 and bus_id != 24[
                        ;print " Here "
                        let new_route first temp_command_value
                        if new_route != send_route[
                          if not empty? send_route[
                            set send_route but-first send_route
                          ]
                          set send_route lput item 0 temp_command_value send_route
                          set-bus-route
                        ]
                      ][
                        if bus_id = 24[
                          ;print " There "
                          if not member? temp_command_value send_route[
                            set send_route lput temp_command_value send_route
                          ]
                        ]
                      ]
                    ]              
                ][
                  if temp_command = "VOTE" [
                    ; execute Vote specific command
                    ;print (word "BUS " bus_number "Message VOTE " temp_command_value)
                    if bus_id = 24 and is-list? temp_command_value and not empty? temp_command_value[
                      update-vote bus_number item 0 temp_command_value item 1 temp_command_value
                      ;print (word "BUS " bus_number "Message VOTE " temp_command_value)
                    ]
                  ]
                ]
              ]
            ]
          ]
        ]
      ]
    ]
    set inbox remove read_msg inbox
  ]
  

end

to update-vote[bus_number choice count_of_bus]
  ask bus 24[

    if not empty? vote[
      foreach vote[
        if item 0 ? = bus_number[
          set vote remove ? vote
        ]
      ]
    ]
    set vote lput (list bus_number choice count_of_bus) vote
  ]
end

to-report construct-message
  let message []
  let bus_capacity get-bus-capacity
  let send_message_flag false

  ; general messages
  set message lput "GEN" message
  if bus_capacity < 1[
    set message lput 1 message
    set send_message_flag true
  ]
    
  ; Bus specific message, Bus ID
  set message lput "BUS" message
  set message lput bus_id message
  
  ; Number of empty seats
  set message lput "CAPACITY" message
  set message lput get-bus-capacity message
  
  ; Bus-stop specific message, Bus-stop ID
  set message lput "BUS_S" message
  set message lput current_stop message
  
  ; Passenger specific message
  set message lput "PASS" message
  
  ; Route specific message
  set message lput "ROUTE" message
  ifelse bus_id = 24 and route_flag and not empty? send_route[
    ;print (word "send_route before for bus" bus_id " " send_route)
    set message lput item 0 send_route message
    set send_route but-first send_route
    ;print (word "send_route after for bus" bus_id " " send_route)
  ][
    ;print (word "send_route other for bus" bus_id " " send_route)
    set message lput send_route message
  ]
  
  ; Vote of individual bus
  set message lput "VOTE" message
  let vote_recieved take-vote
  if item 0 vote_recieved != 0[
    set send_message_flag true
  ]
  set message lput vote_recieved message
  
  report (list send_message_flag message)
end


to communicate
  let message []
  let addressee 0
  let send_flag false

  if current_stop != -1 [

    ; construct message
    set message construct-message
    set send_flag first message
    set message item 1 message
    
    if send_flag[
      if (bus_id != 24) or (get-bus-capacity < 1)[
        ;send message to bus in the neighborhood
        set addressee get-addressee bus_id false
        if addressee != 0[
          send-message addressee message
          ;print (word "BUS normal" message) 
          show (word "Message sent to Bus " addressee)
        ]
      ]
      ; send vote
      if (bus_id != 24)[
        ;print (word "BUS vote" message)
        send-message 24 message
      ]
    ]
  ]
  
  ;print (word "outmessage for BUS" bus_id " " length send_route " send_route " send_route)
  if bus_id = 24 and length send_route > 0[

    set route_flag true
    
    ; construct message
    set message construct-message
    ;print (word "BUS 24 calling" message)
    set send_flag first message
    set message item 1 message
    
    if send_flag[
      ; send message to new bus
      set addressee get-addressee bus_id true
      
      if count buses with [bus_id = addressee] > 0 [
        send-message addressee message
        ;print (word "BUS 24 calling" message)
        show (word "Message sent to Bus " addressee)
      ]
    ]
  ]
end


;; return the number of empty seats
to-report get-bus-capacity
  let empty_seats 0
  let passenger_at_stop 0
  
  if current_stop != -1 [
    set passenger_at_stop length get-passengers-at-stop current_stop
  ]
  
  ifelse bus_type = 1 [
    set empty_seats bus_type1_capacity - (length bus_passengers + passenger_at_stop)
    
  ]
  [ ifelse bus_type = 2 [
      set empty_seats bus_type1_capacity - (length bus_passengers + passenger_at_stop)
    ]
    [ if bus_type = 3 [
        set empty_seats bus_type1_capacity - (length bus_passengers + passenger_at_stop)
      ]
    ]
  ]

  
  report empty_seats
end


to-report take-vote
  let report_vote [0 0]
  let capacity get-bus-capacity
  
  let passengers_left (length get-passengers-at-stop current_stop) - capacity
  
  if passengers_left > 0[
    set waiting_p_count (waiting_p_count + passengers_left)
  ]
  
;  print (word "Waiting p before " waiting_p_count)
  
  if waiting_p_count > bus_type1_capacity[
    let var1 round (passengers_left / bus_type1_capacity)
    let var2 round (passengers_left / bus_type2_capacity)
    let var3 round (passengers_left / bus_type3_capacity)
    
    print (word "var1 " var1 " var2 " var2 " var3 " var3 " passengers_left " passengers_left)
    
    ifelse (var3 >= 1)[
      let vote_count var3
      set report_vote (list 3 vote_count)
      
      set waiting_p_count (waiting_p_count - (vote_count * bus_type3_capacity))
    ][
      ifelse (var3 < 1 and var2 >= 1)[
        let vote_count var2
        set report_vote (list 2 vote_count)
        
        set waiting_p_count (waiting_p_count - (vote_count * bus_type2_capacity))
      ][
        let vote_count var1
        set report_vote (list 1 vote_count)
        
        set waiting_p_count (waiting_p_count - (vote_count * bus_type1_capacity))
      ]
    ]
  ]
  
  if bus_id = 24[
    update-vote 24 item 0 report_vote item 1 report_vote
  ]
  
;  print (word "Waiting p before " waiting_p_count)

  report report_vote
end


to add-bus-type 
  if remainder ticks 2 = 0[
  let green_vote 0
  let yellow_vote 0
  let red_vote 0
  let green_vote_count 0
  let yellow_vote_count 0
  let red_vote_count 0
  
  let winner 0
  let winner_count 0
  let winner_buses_total_capacity 0
  let winner_requested_bus 0
  
  let total_passenger_waiting 0

  let my_vote []
  set all_bus_capacity (all_bus_capacity + get-bus-capacity)
  
  if current_stop != -1[
    set my_vote take-vote
  ]
  
;  print (word "before vote " vote )
  
  foreach vote[
    ifelse item 1 ? = 1[
      set green_vote (green_vote + 1)
      set green_vote_count (green_vote_count + item 2 ?)
    ][
        ifelse item 1 ? = 2[
          set yellow_vote (yellow_vote + 1)
          set yellow_vote_count (yellow_vote_count + item 2 ?)
      ][
          if item 1 ? = 3[
            set red_vote (red_vote + 1)
            set red_vote_count (red_vote_count + item 2 ?)
        ]
      ]
    ]
    
    ; reset the vote
    update-vote item 0 ? 0 0
    
  ]
  
;  print (word "after vote " vote )

  
;  print (word " red " red_vote " green " green_vote " yellow " yellow_vote)
  
  ; voting
  ifelse (red_vote > green_vote) and (red_vote > yellow_vote)[
    set winner 3
    set winner_count red_vote
    set winner_buses_total_capacity (red_vote_count * bus_type3_capacity)
    set winner_requested_bus red_vote_count / red_vote
    
  ][
    ifelse (yellow_vote > green_vote) and (yellow_vote > red_vote)[
      set winner 2
      set winner_count yellow_vote
      set winner_buses_total_capacity (yellow_vote_count * bus_type2_capacity)
      set winner_requested_bus yellow_vote_count / yellow_vote
    ][
      if (green_vote > yellow_vote) and (green_vote > red_vote)[
         set winner 1
         set winner_count green_vote
         set winner_buses_total_capacity (green_vote_count * bus_type1_capacity)
         set winner_requested_bus green_vote_count / green_vote
      ]
    ]
  ]
  
  ask bus_stops [
    set total_passenger_waiting (total_passenger_waiting + length passengers_waiting)
  ]
  
;  print (word " w " winner " all_bus_capacity " all_bus_capacity " total_passenger_waiting " total_passenger_waiting " winner_buses_total_capacity "  winner_buses_total_capacity " total diff " ((all_bus_capacity + winner_buses_total_capacity) - total_passenger_waiting) " " (all_bus_capacity > (total_passenger_waiting - (all_bus_capacity + winner_buses_total_capacity))))
  if winner != 0 and all_bus_capacity > ((all_bus_capacity + winner_buses_total_capacity) - total_passenger_waiting)[
    while [winner_requested_bus > 0][
    add-bus winner
    set winner_requested_bus winner_requested_bus - 1
    ]
    ;print(word " Winner: " winner)
  ]
;  add-bus winner
  set all_bus_capacity 0
]
  
  

end

; b_id: bus Id
; flag_new: If true report new bus id else report nearest bus id
; reports back bus-id of newest/nearest bus 
to-report get-addressee [b_id flag_new]
  let report_id 0
  
  ifelse flag_new [
  ; new bus id
    let current_b_id count buses
    let new_b_id current_b_id + 23
    set report_id new_b_id
  ][
    ; nearest bus
    let near_b min-one-of other buses with [bus_type = 2] [distance myself]
    if near_b != nobody [
      ask near_b [ set report_id bus_id ]
    ]
  ]
  
  report report_id
end



; set up temporary route to target bus-stop for bus_id
to set-temp-route [target]
  let dummy_route []
  let path_list []
  let temp_stop current_stop
  let temp_var1 bus_stop current_stop
  let temp_var2 -1
  
  ; current stop could be -1 if the gent is travelling in between stop
  if current_stop = -1 [
    set temp_stop next_stop 
    set temp_var1 temp_stop
  ]
  
  ask bus_stop temp_stop [
    ;; Construct the turtle path, putting the current bus_stop on the front:
    set path_list fput self nw:path-to bus_stop target
    ; show path_list
  ]
  set dummy_route lput bus_stop current_stop dummy_route
  
  
  ; remove the bus_stop information
  set path_list but-first path_list
  
  while [ not empty? path_list] [
    let path_item first path_list
    ask path_item [
      ;print (word "1. end1 " end1 " end2 " end2 " dummy route " dummy_route)

     ifelse end1 = temp_var1 [
       if member? temp_var1 dummy_route [
         set dummy_route remove temp_var1 dummy_route
       ]
       set dummy_route lput temp_var1 dummy_route
       set temp_var2 end2
       set dummy_route lput temp_var2 dummy_route
       ;print (word "2. end1 " end1 " end2 " end2 " dummy route " dummy_route)
     ][ 
         ifelse end2 = temp_var1 [
         if member? temp_var1 dummy_route [
           set dummy_route remove temp_var1 dummy_route
         ]
         set dummy_route lput temp_var1 dummy_route
         set temp_var2 end1
         set dummy_route lput temp_var2 dummy_route
         ;print (word "3. end1 " end1 " end2 " end2 " dummy route " dummy_route)
       ][
         set temp_var1 end1
         set dummy_route lput temp_var1 dummy_route
         set temp_var2 end2
         set dummy_route lput temp_var2 dummy_route
         ;print (word "4. end1 " end1 " end2 " end2 " dummy route " dummy_route)
       ]
     ]
     

    ]
      set path_list but-first path_list
    ]
  
  ; forming a circular route to return to original point of deviation
  set dummy_route remove-duplicates dummy_route
  let dummy_route_reverse reverse dummy_route
  foreach dummy_route [ set dummy_route_reverse lput ? dummy_route_reverse ]
  
  ; print (word "Dummy route " dummy_route)
  
  set temp_route but-first dummy_route
end


to set-passenger-route
  let temp_bus_route []

  let passenger_destination []
  let distance_passenger []
  
  
  foreach bus_passengers[
    let destination_distance 0
    set passenger_destination lput item 1 ? passenger_destination
    set destination_distance get-shortest-distance item 1 ? current_stop
    set distance_passenger lput (list destination_distance item 1 ?) distance_passenger
  ]
  
  if length distance_passenger > 1[
    set distance_passenger sort-by [first ?1 < first ?2] distance_passenger
  ]
  
  let old_bus_route bus_route
  
  foreach distance_passenger[
    set old_bus_route lput item 1 ? old_bus_route
  ]

  if not empty? temp_bus_route[
    set bus_route old_bus_route
  ]
  
end


to-report get-shortest-distance [bs_1 bs_2]
  let shortest_distance 0
  let shortest_path []
  
  
  ifelse is-link? route bs_1 bs_2 [
    set shortest_distance get-distance bs_1 bs_2
  ][
      
      ask bus_stop bs_1 [
      ;; Construct the turtle path, putting the current bus_stop on the front:
      set shortest_path fput self nw:path-to bus_stop bs_2
      ; show path_list
    ]
      
    set shortest_path but-first shortest_path
    let temp bus_stop bs_1
    
    while [ not empty? shortest_path] [
      let path_item first shortest_path
      ask path_item [
        ifelse end1 = temp[
          set shortest_distance (shortest_distance + get-distance temp end2)
          set temp end2
        ][
          set shortest_distance (shortest_distance + get-distance temp end1)
          set temp end1        
        ]
      ]
      
      set shortest_path but-first shortest_path
    ]
  ]
  report shortest_distance

end

to set-bus-route
  ;print (word " KAABOOM " send_route)
  if not empty? send_route[
    foreach route_list[
      ;print (word "SEND ROUTE of BUS " bus_id " route id : " item 0 ? " recieved ID" item 0 send_route " check " (item 0 send_route = item 0 ?))
      if item 0 send_route = item 0 ?[
        ;print (word "setting ROUTE of BUS " bus_id " route : " item 1 ?)
        set bus_route item 1 ? 
      ]
    ]
  ]
end